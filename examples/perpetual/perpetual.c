// Copyright Steinwurf ApS 2015.
// Distributed under the "STEINWURF RESEARCH LICENSE 1.0".
// See accompanying file LICENSE.rst or
// http://www.steinwurf.com/licensing

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <kodoc/kodoc.h>

/// @example perpetual.c
///
/// Example showing how to use the additional settings and parameters supported
/// by the perpetual code.

void trace_callback(const char* zone, const char* data, void* context)
{
    (void) context;

    if (strcmp(zone, "decoder_state") == 0 ||
        strcmp(zone, "symbol_coefficients_before_read_symbol") == 0)
    {
        printf("%s:\n", zone);
        printf("%s\n", data);
    }
}

int main()
{
    // Seed the random number generator to produce different data every time
    srand(time(NULL));

    // Set the number of symbols and the symbol size
    uint32_t max_symbols = 10;
    uint32_t max_symbol_size = 100;

    // Here we select the code_type we wish to use
    int32_t code_type = kodo_perpetual;

    // Here we select the finite field to use.
    // kodo_binary8 is common choice for the perpetual codec
    int32_t finite_field = kodo_binary8;

    // First, we create an encoder & decoder factory.
    // The factories are used to build actual encoders/decoders
    kodo_factory_t encoder_factory =
        kodo_new_encoder_factory(code_type, finite_field,
                                 max_symbols, max_symbol_size);

    kodo_factory_t decoder_factory =
        kodo_new_decoder_factory(code_type, finite_field,
                                 max_symbols, max_symbol_size);

    kodo_coder_t encoder = kodo_factory_build_coder(encoder_factory);
    kodo_coder_t decoder = kodo_factory_build_coder(decoder_factory);

    // The perpetual encoder supports three operation modes:
    //
    // 1) Random pivot mode (default):
    //    The pivot element is drawn at random
    // 2) Pseudo-systematic
    //    Pivot elements are generated with indices 0,1,2,...,n
    //    After that, the pivots are drawn at random.
    // 3) Pre-charging
    //    For the first "width" symbols, the pivot index is 0. After that,
    ///   the pseudo-systematic mode is used. Finally, pivots are drawn at
    ///   random. The resulting indices: 0(width times),1,2,...,n
    //
    // The operation mode is set with the following API.
    // Note that if both pre-charging and pseudo-systematic is enabled,
    // pre-charging takes precedence.

    // Enable the pseudo-systematic operation mode - faster
    kodo_set_pseudo_systematic(encoder, 1);

    // Enable the pre-charing operation mode - even faster
    //kodo_set_pre_charging(encoder, 1);

    printf("Pseudo-systematic flag: %d\n", kodo_pseudo_systematic(encoder));
    printf("Pre-charging flag: %d\n", kodo_pre_charging(encoder));

    // The width of the perpetual code can be set either as a number of symbols
    // using kodo_set_width(), or as a ratio of the number of symbols using
    // kodo_set_width_ratio().
    //
    // The default width is set to 10% of the number of symbols.
    printf("The width ratio defaults to: %0.2f"
           " (therefore the calculated width is %d)\n",
           kodo_width_ratio(encoder), kodo_width(encoder));

    /// When modifying the width, the width ratio will change as well
    kodo_set_width(encoder, 4);
    printf("The width was set to: %d "
           " (therefore the calculated width ratio is %0.2f)\n",
           kodo_width(encoder), kodo_width_ratio(encoder));

    /// When modifying the width ratio, the width will change as well
    kodo_set_width_ratio(encoder, 0.2);
    printf("The width ratio was set to: %0.2f"
           " (therefore the calculated width is %d)\n",
           kodo_width_ratio(encoder), kodo_width(encoder));

    // Allocate some storage for a "payload". The payload is what we would
    // eventually send over a network.
    uint32_t bytes_used;
    uint32_t payload_size = kodo_payload_size(encoder);
    uint8_t* payload = (uint8_t*) malloc(payload_size);

    // Allocate input and output data buffers
    uint32_t block_size = kodo_block_size(encoder);
    uint8_t* data_in = (uint8_t*) malloc(block_size);
    uint8_t* data_out = (uint8_t*) malloc(block_size);

    // Fill the input buffer with random data
    uint32_t i = 0;
    for(; i < block_size; ++i)
        data_in[i] = rand() % 256;

    // Assign the data buffers to the encoder and decoder
    kodo_set_const_symbols(encoder, data_in, block_size);
    kodo_set_mutable_symbols(decoder, data_out, block_size);

    // Install a custom trace function for the decoder
    kodo_set_trace_callback(decoder, trace_callback, NULL);

    uint32_t lost_payloads = 0;
    uint32_t received_payloads = 0;
    while (!kodo_is_complete(decoder))
    {
        // The encoder will use a certain amount of bytes of the payload buffer
        bytes_used = kodo_write_payload(encoder, payload);
        printf("Payload generated by encoder, bytes used = %d\n", bytes_used);

        // Simulate a channel with a 50% loss rate
        if (rand() % 2)
        {
            lost_payloads++;
            printf("Symbol lost on channel\n\n");
            continue;
        }

        // Pass the generated packet to the decoder
        received_payloads++;
        kodo_read_payload(decoder, payload);
        printf("Payload processed by decoder, current rank = %d\n\n",
               kodo_rank(decoder));
    }

    printf("Number of lost payloads: %d\n", lost_payloads);
    printf("Number of received payloads: %d\n", received_payloads);

    // Check that we properly decoded the data
    if (memcmp(data_in, data_out, block_size) == 0)
    {
        printf("Data decoded correctly\n");
    }
    else
    {
        printf("Unexpected failure to decode, please file a bug report :)\n");
    }

    // Free the allocated buffers and the kodo objects
    free(data_in);
    free(data_out);
    free(payload);

    kodo_delete_coder(encoder);
    kodo_delete_coder(decoder);

    kodo_delete_factory(encoder_factory);
    kodo_delete_factory(decoder_factory);

    return 0;
}
